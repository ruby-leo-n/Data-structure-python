컴퓨터를 이용하여 자료를 처리하려면 먼저 컴퓨터가 잘다룰 수 있는 형태로 표현해주어야만 한다.
컴퓨터에서도 자료들을 정리하고 조직화 하는 여러가지 구조들이 있다. 
이를 자료구조라고 한다.

선형자료구조: 항목들을 순서대로 나열하여 저장하는 자료구조의 방식이다. 
항목들은 접근하는 방법에 따라 세분화되는데, 스택이나 큐, 덱은 항목의 접근이 전단 후단으로 제한된다.
리스트는 가장 자유로운 선형자료구조이며 임의의 위치에 항목을 삽입하여 삭제할 수 있다.

비선형자료구조: 저장되는 항목들이 보다 복잡한 연결 관계를 갖는다. 
트리는 조직도 같은 계층 구조를 표현하기 적합하다
힙 트리는 우선순위 큐를 효율적으로 표현할 수 있다.
이진 탐색트리나 AVL트리는 탐색을 의한 트리 구조이다.
그래프는 지도나 인터넷 망 등 가장 복잡한 연결관계를 표현할 수 있다. 
간선에 가중치가 할당된 가중치 그래프는 최단 경로 탐색과 같은 문제를 해결하는 기본 구조로 사용된다.

자료구조는 배열구조와 연결구조로 표현할 수 있다.
알고리즘은 순환이나 반복 구조를 이용하여 구현할 수 있다.
정렬은 주어진 자료들을 어떤 기준에 따라 순서대로 나열하는 것으로, 효율적인 정렬을 위해서는 다양한 자료구조를 활용해야 한다.
효율적인 탐색을 위해선 적절한 자료구조와 알고리즘이 필수적이다.

데이터는 자료구조를 통해 표현되고 이를 이용하여 주어진 문제를 해결하기 위한 효과적인 절차가 필요하다.
이와 같이 어떤 문제를 해결하는 절차를 알고리즘이라고 한다.

알고리즘은 특정한 일을 수행하는 명령어들의 집합으로 볼 수 있다.
알고리즘의 조건으로 0개 이상의 입력이 존재해야 한다.
1개 이상의 출력이 존재해야 한다.
각 명령어의 의미는 모호하지 않고 명확해야 한다.(명확성)
한정된 수의 단계 후에는 반드시 종료되어야 한다.(유한성)
각 명령어들은 실행 가능한 연산이어야 한다.(유효성)

알고리즘의 기술 방법은 4가지가 있다.
자연어, 흐름도(flow chart), 유사코드(pseudo-code), 프로그래밍 언어로 알고리즘을 기술할 수 있다.

추상의 의미는 어떤 자료나 연산이 제공되는가 만을 정의하고 어떻게 구현되는가는 정의하지 않는다
추상자료형은 자신을 사용하는 사용자 프로그램에게는 구현에 관한 세부사항들은 감추고 간단한 인터페이스만을 제공한다.
추후에 구현 방법이 변경되더라도 인터페이스만을 정확하게 지켜진다면 사용자는 변경된 내용을 힘들게 공부할 필요 없이 기존과 동일하게 사용할 수 있다.
이것이 정보은닉의 기본개념이다.

추상자료형은 일반함수보다는 클래스로 구현하는 것이 더 바람직하다.
추상자료형의 데이터와 연산이 클래스의 상태와 행위에 더 정확히 대응되기 때문이다. 

파이썬은 다양한 모듈을 제공하는데, 모듈을 사용하기 위해서는 먼저 import로 모듈을 코드에 포함해야 한다.
time 모듈은 운영체제가 제공하는 다양한 시간관련 기능을 제공하는데, time.time()은 컴퓨터의 현재 시각을 반환하는 함수이다.

시간으로 알고리즘의 성능을 측정하는 것은 간단하지만 몇가지 문제가 있다.
1.반드시 동일한 조건의 하드웨어를 사용하여 실행시간을 측정해야 한다.
2.소프트웨어 환경도 동일해야 한다. 컴파일 방식의 언어와 인터프리트 방식의 언어는 실행속도에서 큰 차이가 있다.
3.성능비교에 사용했던 데이터가 아닌 다른 데이터에 대해서는 다른 결과가 나올 수 있어 실험되지 않은 입력에 대해서는 실행시간을 주장할 수 없다.
4.반드시 알고리즘을 구현해야 한다. 

여러 알고리즘이 있을 때 구현하지 않고 각 알고리즘의 효율성을 비교하는 것은 알고리즘의 복잡도 분석으로 가능하다.
입력의 개수를 n이라 할 때, 이 방법은 n이 증가함에 따라서 실행시간이 어떤 형대로 증가하는지 만을 분석하는데, 
알고리즘을 구현하지 않고도 모든 입력에 대해 실행 하드웨어나 소프트웨어 환경과 관계없이 알고리즘의 효율성을 평가할 수 있다.

복잡도 분석 방법은 절대적인 실행 시간이 아니라 알고리즘을 이루고 있는 연산들의 횟수를 분석한다.
이들은 보통 입력의 개수 n에 영향을 받는데, 연산의 수를 n의 함수로 나타낸 것을 시간복잡도 함수라고 하고 T(n)이라고 표기한다.

빅오표기법 
시간복잡도 함수 T(n)은 입력의 개수 n에 대한 상당히 복잡한 수식으로 나타낼 수 있다.
그러나 시간복잡도 함수는 차수가 가장 큰 항의 영향이 절대적이 된다. 
시간 복잡도 함수에서 불필요한 정보를 제거하고 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법을 빅오표기법이라고 하는데,
다음과 같이 정의한다. [두개의 함수 f(n)과 g(n)이 주어졌을 때 모든 n>n0에 대해 |f(n)|<=c|g(n)|을 만족하는 상수 c와 n0가 존재하면 f(n)=O(g(n))]
따라서 빅오표기법은 n에 따른 함수의 상한을 의미한다.

빅오표기법은 상한을 표기한 것이므로 상한은 여러개가 존재할 수 있다.
물론  빅오표기법은 최소차수 함수로 표기되었을 경우만 의미가 있다. 
빅오의 이와 같은 문제점을 보완하기 위하여 빅오메가, 빅세타 표기법이 있다. 빅오메가는 어떤 함수의 하한을 표기하는 방법이고, 빅세타는 동일한 함수로 상한과 하한을 만들수 있는 경우를 말한다.
빅오메가 표기법[두개의 함수 f(n)과 g(n)이 주어졌을 때 모든 n>n0에 대해 |f(n)|>=c|g(n)|을 만족하는 상수 c와 n0가 존재하면 f(n)=오메가(g(n))이다.]
빅세타 표기법[두개의 함수 f(n)과 g(n)이 주어졌을 때 모든 n>n0에 대해 c1|g(n)|<=|f(n)|<=c2|g(n)|을 만족하는 상수 c1와 c2, n0가 존재하면 f(n)=세타(g(n))이다.]

대부분의 경우 알고리즘에 최대한 불리한 입력 데이터를 사용하는 최악의 경우의 실행시간이 가장 중요하다.
같은 알고리즘도 입력의 종류에 따라 처리시간이 크게 달라질 수 있다.

시간복잡도 분석: 재귀 알고리즘
재귀 호출이란 어떤 함수가 자기 자신을 다시 호출하여 문제를 해결하는 프로그래밍 기법이다.
재귀 알고리즘이란 재귀는 본질적으로 재귀적인 문제나 그러한 자료구조를 다루는 프로그램에 적합하다.
재귀 알고리즘은 자신을 재귀적으로 호출하는 부분과 재귀호출을 멈추는 부분으로 구성되어 있다.
만약 순환 호출을 멈추는 부분이 없다면 시스템 스택을 다 사용할 때까지 순환적으로 호출되다가 결국 오류를 내고 멈출 것이다.

많은 경우 재귀은 반복구조로 변환할 수 있다. 특히 재귀호출이 끝에서 이루어지는 경우는 다음과 같이 간단히 반복구조로 바꿀 수 있다.
재귀는 트리와 같은 특정한 문제에 대해서 반복에 비해 훨씬 명확하고 간결한 알고리즘을 나타내지만, 실행속도 면에서는 많은 경우 함수 호출의 부담에 의해 반복보다 느리다.
재귀는 이해하기 쉽다는 것이 장점이나 특정 자료구조에서 효율적이고 그 외에는 수행시간과 기억공간의 사용에 있어서는 비효율적이다.

재귀가 더 빠를 경우: 거듭제곱 구하기
x^n을 구하는 함수를 반복으로 구하면 O(n)이지만 더 효율적인 알고리즘이 가능하다
x^n = (x^2)^(n/2)를 사용하는 것이다. n이 짝수인 경우에는 x^2을 먼저 계산하고 이 값을 n/2승하면 된다. 
n이 홀수이면 (n-1)/2승하고 여기에 x를 곱해주면 같은 결과가 된다. 
이 경우 알고리즘이 순환적으로 호출될 때 마다 문제의 크기가 절반씩 줄어들게 된다.
따라서 시간복잡도는 O(log_2_n)이다. 반복으로 구현한 함수보다 훨씬 훌륭한 알고리즘이다.

순환이 느린 경우가 많다: 비보나치 수열
비보나치 수열을 순환으로 사용하는 경우 단순하게 구현이 가능하지만 매우 비효율적이다. 
왜냐하면 중간에 계산되었던 값을 기억하지 않고 다시 계산하기 때문이다. n이 작을 때는 중복계산이 비교적 적지만 
값이 커질수록 엄청난 재귀호출이 필요하게 된다. 예를 들어 n이 25이면 25만번의 호출을 해야한다.
이 알고리즘의 시간복잡도는 O(2^n)으로 매우 비효율적이다
반복구조로 구하는 경우 O(n)이다. 
*물론 피보나치 수열을 반복이나 동적 계획법으로 구현하면 O(n)의 시간이 걸리지만 행렬의 거듭제곱으로 구하는 경우 O(log_2_n)만에도 구할 수 있다.

재귀의 경우 복잡한 문제를 쉽게 해결할 수 있다.
하노이의 탑문제가 재귀의 위력을 보여주는 극명한 문제이다. 
이 문제를 순환으로 해결해 보자. 순환 알고리즘에서는 순환이 일어날수록 문제의 크기가 작아져야 한다.
이때 문제의 크기는 이동하여야 하는 디스크의 개수가 될 것이다. n개의 원판이 A에 쌓여있는 문제를 다음과 같이 해결할 수 있을 것이다.
1. 먼저 쌓여있는 n-1개의 원판을 B로 옮긴다. C를 임시막대로 사용한다.
2. 이제 제일 밑에 있는 원판을 C로 옮긴다. 
3. B로 옮겨져 있는 n-1개의 원판을 C로 옮긴다. A를 임시막대로 사용한다.

단계2는 1개의 원판을 이동하는 것이므로 매우 쉽다. n-1개의 원판을 옮기는 단계1과 단계3만 처리할 수 있으면 문제는 해결된다.
중요한 것은 단계1과 단계3에서 문제의 크기가 작아졌다는 것이다. n개가 아니라 n-1개만 옮길 수 있으면 된다.
이 방법을 계속 적용한다면 뭔가 답이 보일 것 같다. 단계1과 단계3은 동일한 문제이다. 
각각 C와 A를 임시로 사용하면 되고, 두 경우 모두 바닥에는 움직일 원판보다 더 큰 원판이 있으므로 원판 크기 조건을 걱정할 필요는 없다.

이 경우 재귀를 사용하므로 T(n)은 다음과 같다.
하노이의 탑 알고리즘은 시간복잡도가 O(2^n)이다.

