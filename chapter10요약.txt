그래프는 연결된 객체들 사이의 관계를 표현할 수 있는 자료구조이다.
객체는 정점으로 위치간의 관계는 간선으로 표현한다.
그래프는 정점과 간선의 집합으로 구성되는데 정점은 노드, 간선은 링크라고 한다.
그래프는 G = (V,E)와 같이 표시하는데 V(G)는 그래프 G의 정점들의 집합을 E(G)는 그래프 G의 간선들의 집합을 의미한다.

무방향 그래프: 간선에 방향이 표시되지 않은 그래프, 하나의 간선은 양방향으로 갈 수 있는 길을 의미한다.
(A,B)와 (B,A)는 동일한 간선이다.

방향 그래프: 간선에 방향성이 존재하는 그래프를 말한다. 간선은 화살표로 표시되는데 한쪽 방향으로만 갈 수 있다.
<A,B>는 A에서 B로만 갈 수 있는 간선을 의미한다. <A,B>와 <B,A>는 서로 다른 간선이다.

가중치 그래프: 간선에 비용이나 가중치가 할당된 그래프이다.

부분 그래프: 그래프 G를 구성하는 정점의 집합 V(G)와 간선의 집합 E(G)의 부분집합으로 이루어진 그래프를 G의 부분 그래프라고 한다.

인접 정점: 간선에 의해 직접 연결된 정점을 말한다.

정점의 차수: 정점에 연결된 간선의 수를 말한다. 무방향 그래프에서는 정점에 인접한 정점의 수를 말한다.
모든 정점의 차수를 합하면 간선 수의 2배가 된다. 외부에서 오는 간선의 수를 진입 차수, 외부로 향하는 간선의 수를 진출 차수라 한다.
방향 그래프에서 정점의 진입차수와 진출차수의 합은 간선의 수와 같다.

경로: 간선을 따라 갈 수 있는 길, 경로는 무조건 모든 길이 연결되어야 경로가 된다. 길이 하나라도 존재하지 않으면 경로가 되지 않는다.

단순 경로: 경로 중에서 반복되는 간선이 없는 경로를 단순 경로라고 한다. 단순 경로의 시작 정점과 종료 정점이 같다면 이러한 경로를 사이클이라고 한다.

연결 그래프: 모든 정점들 사이에 경로가 존재하는 그래프를 연결 그래프라고 한다. 이 그래프에서는 따로 떨어진 정점이 없이 모든 정점들이 연결되어 있다.
그렇지 않는 그래프를 비연결 그래프라고 한다.

트리: 사이클을 가지지 않는 그래프를 말한다. 연결 그래프에서 사이클이 없으면 그래프의 임의의 두 정점을 연결하는 경로는 오직 하나 뿐이다.
만약 두 개의 경로가 존재한다면 이들에 의해 사이클이 형성되기 때문이다.

완전 그래프: 모든 정점 간에 간선이 존재하는 그래프를 말한다.

인접행렬:
1. 간선의 수와 무관하게 항상 n^2개의 메모리 공간이 필요하다 따라서 정점에 비해 간선의 수가 매우 많은 조밀 그래프에서 효과적이다.
2. x와 y를 연결하는 간선의 유무는 M[x][y]를 조사하면 바로 알 수 있다. 따라서 getEdge(x,y)의 시간 복잡도는 O(1)이다.
3. 정점의 차수를 구하는 degree(v)는 정점 v에 해당하는 행을 조사하면 되므로 O(n)이다. 
4. 정점 v의 인접 정점을 구하는 adjacent(v)연산은 해당 행의 모든 요소를 검사하면 되므로 O(n)의 시간이 요구된다.
5. 그래프에서 존재하는 모든 간선의 수를 알아내려면 인접 행렬 전체를 조사해야 하므로 n^2번의 조사가 필요하다. 따라서 O(n^2)의 시간이 요구된다.

인접리스트:
1. n개의 연결리스트가 필요하고 2e개의 노드가 필요하다 즉, n+2e개의 메모리 공간이 필요하다. 따라서 정점에 비해 간선의 수가 적은 희소 그래프에서 효과적이다.
2. getEdge(x,y)연산은 정점x의 연결 리스트 전체를 조사해야 한다. 정점 x의 차수를 d_x라고 한다면 이 연산의 시간 복잡도는 O(d_x)이다.
3. 정점 y의 차수 degree(y)는 y의 연결 리스트의 길이를 반환하면 된다. 따라서 시간 복잡도는 O(d_y)
4. 정점 y에 간선으로 직접 연결된 모든 정점을 구하는 adjacent(y) 연산도 해당 연결 리스트의 모든 요소를 방문해야 되므로 O(d_y)
5. 전체 간선의 수를 알아내려면 헤더 노드를 포함하여 모든 인접 리스트를 조사해야 하므로 O(n+e)의 연산이 요구된다.



