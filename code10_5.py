import collections as cols
# 이제 덱 클래스를 cols.deque으로 사용할 수 있다.

Mygraph = {"A": {"B", "C"},
           "B": {"A", "D"},
           "C": {"A", "D", "E"},
           "D": {"B", "C", "F"},
           "E": {"C", "G", "H"},
           "F": {"D"},
           "G": {"E", "H"},
           "H": {"E", "G"}}

# 너비우선탐색(BFS):
# 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.
# 너비우선탐색을 위해서는 가까운 거리에 잇는 정점들을 차례로 저장하고, 들어간 순서대로 꺼낼 수 있는 자료구조가 필요하다.
# 너비우선탐색은 큐를 사용하는 탐색이라 생각하면 편하다.
# 정점들이 방문될 때마다 큐에 인접 정점을 삽입하고 더 이상 방문할 인접 정점이 없는 경우,
# 큐의 맨 앞에서 정점을 꺼내 그 정점과 인접한 정점들을 차례대로 방문한다.
# 초기상태의 큐에는 시작 정점만이 저장되어 있고 너비우선탐색은 큐가 공백상태가 될 때까지 계속한다.


# 너비우선탐색을 구현하기 위해서는 원형큐 클래스 CircularQueue를 사용할 수도 있고, 파이썬의 queue모듈을 사용할 수 있다.
# 하지만 여기선 파이썬의 collections모듈을 사용할 것이다.
# 이 모듈은 내장 자료형인 튜플이나 딕셔너리에 대한 확장 데이터 구조들을 제공하는데
# 전단과 후단에서 효율적으로 삽입, 삭제가 가능한 deque클래스를 포함하고 있다.
# 스택이나 큐가 필요한 경우 이를 구현하지 않고 collections 모듈의 deque을 이용해 처리할 수 있다.
# 덱을 큐나 스택처럼 사용하면 된다.

def bfs(graph, start):
    visited = set([start])  # 맨 처음에는 start만 방문 정점이다.
    queue = cols.deque([start])  # 덱 객체 생성 (큐로 사용)
    while queue:  # 큐가 공백이 아닌 동안 계속 반복
        vertex = queue.popleft()  # 큐에서 왼쪽 객체를 뺀다.
        print(vertex, end=" ")  # 출력
        nbr = graph[vertex] - visited  # 차집합 연산: 인접 정점 중 방문한 정점을 뺀 것들의 집합
        for v in nbr:
            visited.add(v)
            queue.append(v)


bfs(Mygraph, "A")

# 너비우선탐색은 그래프가 인접 리스트로 표현되어 있으면 전체 수행시간이 O(n+e)이며,
# 인접 행렬로 표현되어 있는 경우는 O(n^2) 시간이 걸린다.
# 너비우선탐색도 깊이우선탐색과 같이 희소 그래프를 사용하는 경우 인접리스트를 사용하는게 효율적이다.
