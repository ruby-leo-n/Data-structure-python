해싱이란
킷값에 산술적인 연산을 적용하여 레코드가 저장되어야 할 위치를 직접 계산하는 것이다.
따라서 탐색은 테이블에 있는 레코드를 하나씩 비교하는 것이 아니라 탐색키로 부터 레코드가 있어야 할 위치를 
계산하고 그 위치에 레코드가 있는지를 확인만 하면 된다.

해시함수란
해싱에서 킷값으로부터 레코드가 저장될 위치를 계산하는 함수를 해시함수라고 한다.

해시테이블
해시 함수에 의해 계산된 위치에 레코드를 저장한 테이블을 해시 테이블이라고 한다.

해싱은 해시함수로 인해 키값을 계산하여 저장된 위치를 찾기 때문에 O(1)이다.
하지만 탐색키가 문자열이나 엄청 큰 정수인 경우 문제가 발생한다.
키값이 큰 경우 메모리가 부족하여 상대적으로 작은 배열을 사용해야 하고 탐색킬를 더 이상 직접 배열의 인덱스로 사용할 수 없다.
대신에 탐색키를 작은 정수로 대응시키는 해시 함수가 필요하다.
해시함수는 탐색키를 입력받아 해시 주소를 계산하는데 삽입이나 삭제, 탐색 연산은 모두 이 주소에서 이루어진다.

서로 다른 키가 해시함수에 의해 같은 주소로 계산되는 상황을 충돌이라고 한다.
충돌을 일으키는 키들을 동의어라고 한다. 
충돌이 슬롯수보다 많이 발생할 수 있다. 이러한 상황을 오버플로라 한다.
오버플로가 발생하면 해당 버킷에 더 이상 항목을 저장할 수 없게 된다.
따라서 해싱에서는 오버플로를 반드시 해결해야 한다.

선형조사법은 해싱함수로 계산된 버킷에 빈 슬롯이 없는 경우 다음 버킷에 빈 슬롯이 있는지 찾는 방법이다.
선형조사법의 경우 비어있는 공간이 나올 때까지 계속된다. 만약 테이블의 끝에 도달하면 다시ㅣ 테이블의 처음으로 간다.
만약 조사과정에서 처음 충돌이 발생한 곳으로 다시 돌아왔다면 테이블이 가득찬 상태이다.

삽입 연산 시 한번 충돌이 발생한 위치에서 항목들이 집중되는 현상을 볼 수 있는데 이것을 군집화 현상이라고 한다.

탐색 연산 시 해당 주소에 같은 키의 레코드가 있으면 탐색은 성공이다 그러나 없는 경우에는 삽입과 같은 방법으로 계속 다음 버킷을 검사해야 한다.
이 과정은 해당 키의 레코드를 찾거나 레코드가 없는 버킷을 만나거나 모든 버킷을 다 검사할 때까지 진행된다. 

삭제 연산 시 선형 조사법에서 항목이 삭제되면 탐색이 불가능해질 수 있다. 찾고자 하는 위치 앞에 삭제가 발생한 경우
선형조사법에서 탐색이 중단되므로 찾을 수 없게 된다. 이 문제를 해결하기 위해서는 빈 버킷을 두가지로 분류해야 한다.
즉, 한번도 사용하지 않은 것과 사용되었다가 삭제되어 현재 비어있는 버킷으로 나누어야 한다. 탐색과정은 한 번도 사용이 
안 된 버킷을 만나야만이 중단되도록 한다.

이차조사법
군집화 문제를 완화하기 위한 방법으로 충돌이 발생하면 다음에 조사할 위치를 다음 식에 의해 결정하는 방법이다.
(h(k)+i*i)%M for i = 0,1,...,M-1
따라서 조사되는 위치는 h(k), h(k)+1, h(k)+4, h(k)+9와 같이 움직인다.
물론 계산된 주소에 나머지 연산을 적용해야 한다. 이 방법은 군집화 현상을 완화시킬 수 있는데,
물론 2차 집중 문제를 일으킬 수는 없지만 1차 집중처럼 심각한 것은 아니다. 2차 집중의 이유는 동일한 위치로 사상되는 
여러 탐색키들이 같은 순서에 의하여 빈 버킷을 조사하기 때문이다. 이것은 이중해싱으로 해결할 수 있다.

이중해싱
충돌이 발생해 저장할 다음 위치를 결정할 때, 원래 해시함수와 별개의 다른 해시함수를 이용하는 방법이다.
선형조사법과 이차조사법은 충돌이 발생하면 해시 함수 값에 각각 1또는 i^2을 더하여 다음 위치를 얻는다.
따라서 해시 함수 값이 같으면 다음 위치도 같게 된다. 이중 해싱법은 해시 함수 값이 같더라도 탐색키가 다르면
서로 다른 조사 순서를 갖도록 하여 2차 집중을 완화할 수 있다.

체이닝
체이닝은 하나의 버킷에 여러개의 레코드를 저장할 수 있도록 하는 방법으로, 버킷은 보통 연결 리스트로 구현한다.
체이닝에서 항목을 탐색하거나 삽입하고자 하면 킷값의 버킷에 해당하는 연결리스트에서 독립적으로 탐색이나 삽입이 이루어진다.
체이닝은 해시 테이블을 연결리스트로 구성하므로 필요한 만큼의 메모리만 사용하게 되어 공간적 사용효율이 매우 우수하다.
또한 오버플로가 발생할 경우도 해당 버킷에 할당된 연결리스트만 처리하면 되므로 수행시간에서도 효율적이다.

해시함수를 구성하는 방법
1.제산함수
나머지 연산을 이용하여 해쉬값을 추출하는 것이다.가능하면 해시테이블의 크기 (나누는 수)를 소수로 선택해야 한다. 
즉, 1과 자기자신을 약수로 가지는 수라면 0 ~ 소수-1을 골고루 사용하는 값을 만들어 낼 수 있기 때문이다.

2.폴딩함수
탐색키가 해시테이블의 크기보다 더큰 정수인 경우 사용된다. 
예를 들어 탐색키가 32비트이고 해시테이블의 인덱스가 16비트라고 생각해보자
만약 탐색키의 일부만을 사용한다면 많은 충돌이 발생할 수 있다. 보다 좋은 방법은 탐색키를 몇개의 부분으로 나누어 
이를 더하거나 비트별 xor와 같은 부울연산을 이용하는 것인데 이를 폴딩이라고 한다.

폴딩함수에서 탐색키를 나누고 더하는 방법에는 이동폴딩과 경계폴딩이 대표적이다.
이동폴딩의 경우 탐색키를 여러 부분으로 나눈 값들을 더하고 해시주소를 얻는다.
경계폴딩의 경우 탐색키를 여러 부분으로 나누고 이웃한 부분으르 거꾸로 더하여 해시 주소를 얻는다.

3.중간제곱함수
탐색키를 제곱하여 중간의 몇 비트만 취해서 해시주소를 생성하는 방법이다. 제곱한 값의 중간비트들은 대개 탐색키의 모든 자리의 숫자들과 관련이 있다.
따라서 두 킷값에서 몇 개의 자리가 같더라도 서로 다른 해싱 주소를 갖게 된다. 탐색키를 제곱한 값의 중간 비트들은 보통 비교적 고르게 분산된다.

4.비트추출방법
해시테이블의 크기가 M = 2^k일때 탐색키를 이진수로 간주하여 임의의 위치의 k개의 비트를 해시주소로 사용하는 것이다.
이 방법은 간단하지만 탐색키의 일부정보만을 사용하므로 해시주소의 집중 현상이 일어날 가능성이 많다.

5.숫자분석방법
숫자로 구성된 키에서 각 위치마다 수의 특징을 미리 알고 있을 때 유용하다. 키의 각 위치에 있는 숫자 중에서 편중되지 않는 수들을 
해시 테이블의 크기에 적합한 만큼 조합하여 해시 주소로 사용하는 방법이다.

탐색키가 문자열인 경우는 code7_4에서 다룬다.