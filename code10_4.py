# 기본적인 그래프의 탐색방법에는 깊이우선탐색과 너비우선탐색이 있다.

Mygraph = {"A": {"B", "C"},
           "B": {"A", "D"},
           "C": {"A", "D", "E"},
           "D": {"B", "C", "F"},
           "E": {"C", "G", "H"},
           "F": {"D"},
           "G": {"E", "H"},
           "H": {"E", "G"}}

# 깊이우선탐색(DFS):"스택"을 이용한 미로탐색과 유사하다.
# 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 다른 방향을 탐색하는 방법으로 출구를 찾는 방법이다.

# 탐색과정에 한번 방문한 정점은 다시 탐색하지 않아야 하므로 이미 방문한 정점을 관리하는 집합이 필요하다.
# 이를 visited라 하면 맨 처음에는 당연히 visited가 공집합이어야 한다.
# 이때 한번 방문한 정점은 반드시 visited에 넣어야 한다.
# 탐색은 그 정점과 인접한 정점들 중에서 아직 방문하지 않은 정점으로만 가능하다.
# 더 이상 방문하지 않은 인접 정점이 없으면 가장 마지막에 만났던 정점으로 되돌아간다.
# 이 방법은 가장 최근에 만났던 갈림길로 되돌아가야 하므로 "스택"을 사용하여 구현할 수 있지만 순환의 형태로 구현하는 것이 더 직관적이다.

# 깊이우선탐색 코드는 다음과 같다. 매개변수로 그래프, 시작 정점, 그리고 visited를 사용하는데,
# 디폴트 인수를 사용해 dfs가 처음 호출되면 공백상태의 방문정점 집합 visited를 생성하도록 한다.


def dfs(graph, start, visited=set()):  # 처음 호출할때 visited는 공집합
    if start not in visited:
        visited.add(start)
        print(start, end=" ")
        nbr = graph[start] - visited
        # 아직 방문하지 않은 정점 집합을 구하기 위해 집합 클래스에서 제공하는 (-)차집합 연산을 이용
        for v in nbr:
            dfs(graph, v, visited)  # 이전에 추가한 원소를 가진채로 함수를 호출함


dfs(Mygraph, "A")

# 깊이우선탐색을 하는 시간은 그래프가 인접리스트로 표현되었다면 O(n+e)이고
# 인접행렬로 표현되었다면 O(n^2)이다.
# 따라서 희소그래프인 경우 깊이우선탐색은 인접 리스트의 사용이 인접행렬보다 시간적으로 유리함을 뜻한다.
